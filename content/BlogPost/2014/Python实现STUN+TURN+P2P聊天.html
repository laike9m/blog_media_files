<p>作为技术验证，最近实现了一下NAT穿透，并在此基础上完成了P2P聊天的客户端（虽然只能在命令行中打字）。理论上能不论电脑处于何种类型NAT设备后，均可以实现P2P聊天。代码和使用方法参见<br><a href="https://github.com/laike9m/PyPunchP2P">https://github.com/laike9m/PyPunchP2P</a><br>
这篇文章主要（简单）介绍一下必要的背景知识和原理，github上已有的内容就不再说明。</p>

<h2>
<a name="%E4%BB%80%E4%B9%88%E6%98%AFnat%E7%A9%BF%E9%80%8F" class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AFnat%E7%A9%BF%E9%80%8F"><span class="octicon octicon-link"></span></a>什么是NAT穿透？</h2>

<p><a href="http://www.cs.nccu.edu.tw/%7Elien/Writing/NGN/firewall.htm">穿越防火墙技术</a></p>

<h2>
<a name="%E4%BB%80%E4%B9%88%E6%98%AFstun-turn" class="anchor" href="#%E4%BB%80%E4%B9%88%E6%98%AFstun-turn"><span class="octicon octicon-link"></span></a>什么是STUN, TURN？</h2>

<p><a href="https://hacks.mozilla.org/2013/07/webrtc-and-the-ocean-of-acronyms/">WebRTC and the Ocean of Acronyms</a></p>

<h2>
<a name="%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0nat%E7%A9%BF%E9%80%8F" class="anchor" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0nat%E7%A9%BF%E9%80%8F"><span class="octicon octicon-link"></span></a>如何实现NAT穿透？</h2>

<p><a href="http://www.bford.info/pub/net/p2pnat/index.html">Peer-to-Peer Communication Across Network Address Translators</a></p>

<p>喂这就算介绍完了吗(╯‵□′)╯︵┻━┻<br>
咳咳，总之原理部分就这样吧</p>

<p><br></p>

<h2>
<a name="pypunchp2p%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" class="anchor" href="#pypunchp2p%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="octicon octicon-link"></span></a>PyPunchP2P工作流程</h2>

<h3>
<a name="part-one-%E8%BF%9E%E6%8E%A5" class="anchor" href="#part-one-%E8%BF%9E%E6%8E%A5"><span class="octicon octicon-link"></span></a>PART ONE: 连接</h3>

<p>假定你已经运行了<code>server.py</code>，并让其监听<code>1234</code>这个端口。客户端A首先会通过从<a href="https://pypi.python.org/pypi/pystun">pystun</a>里面弄出来的那部分代码检测自己的NAT类型  </p>

<div class="highlight highlight-python"><pre><span class="n">nat_type</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nat_type</span><span class="p">()</span>
</pre></div>

<p>然后通知服务器端，发起连接请求，同时告知服务器自己的NAT类型。<code>client.py</code>的第三个参数是<strong>pool</strong>值，这个值是用来匹配客户端用的。如果说两个发起连接的客户端有一样的pool值，那么就认为它们是希望通信的客户端。指定的pool值也会发送给服务器。  </p>

<pre><code>self.request_for_connection(nat_type_id=NATTYPE.index(nat_type))
</code></pre>

<p>其中  </p>

<pre><code>NATTYPE = (FullCone, RestrictNAT, RestrictPortNAT, SymmetricNAT)
</code></pre>

<p>如果一切顺利，服务器接到了这个请求，那么它会保存客户端A的信息（addr, pool, nat_type），同时继续等待另一个客户端发起请求。<br>
好，现在客户端B也发了个请求过来，并且pool值和之前相同。服务器意识到A和B希望和对方通信，于是分别把A和B的信息发给对方。显然，这就是<strong>STUN server</strong>的本职工作。</p>

<div class="highlight highlight-python"><pre><span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">poolqueue</span><span class="p">[</span><span class="n">pool</span><span class="p">]</span><span class="o">.</span><span class="n">addr</span><span class="p">,</span> <span class="n">addr</span>  
<span class="n">nat_type_id_a</span><span class="p">,</span> <span class="n">nat_type_id_b</span> <span class="o">=</span> <span class="n">poolqueue</span><span class="p">[</span><span class="n">pool</span><span class="p">]</span><span class="o">.</span><span class="n">nat_type_id</span><span class="p">,</span> <span class="n">nat_type_id</span>  
<span class="n">sockfd</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">addr2bytes</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">nat_type_id_a</span><span class="p">),</span> <span class="n">b</span><span class="p">)</span>  
<span class="n">sockfd</span><span class="o">.</span><span class="n">sendto</span><span class="p">(</span><span class="n">addr2bytes</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">nat_type_id_b</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
</pre></div>

<p>至此第一部分的工作就完成了，clientA和clientB已经连接起来了，祈祷到这里一切顺利吧。</p>

<h3>
<a name="part-two-%E9%80%9A%E4%BF%A1" class="anchor" href="#part-two-%E9%80%9A%E4%BF%A1"><span class="octicon octicon-link"></span></a>PART TWO: 通信</h3>

<p>注意到我们之前并没有利用NAT类型信息，下面就需要了。让我们分情况看看：  </p>

<h4>
<a name="%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E6%96%B9%E6%98%AFsymmetric-nat" class="anchor" href="#%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E6%96%B9%E6%98%AFsymmetric-nat"><span class="octicon octicon-link"></span></a>至少有一方是symmetric NAT</h4>

<p>这是最优先考虑的情况，因为symmetric NAT是最让人头大的情况。这种情况下只能通过服务器来转发消息。于是我们的服务器华丽变身为<strong>TURN server</strong>。当然，服务器不可能什么包都转发，所以这种通信方式下双方的消息带有一个<code>msg</code>的前缀，目的就是标识出这是希望服务器转发的消息而不是PART ONE中发起连接的那种消息。我们的服务器是不可能使用多个端口的，因为如果端口和之前建立连接时不同，那么服务器转发的消息就会直接被symmetric NAT丢弃了。既然和之前使用的是一个socket，那么标识显然是必要的。<br>
还有个问题是转发给谁。这一点无须担心，在建立连接时服务器已经把两个client配对了，如果是从一边来的消息，它会自动转发给另一边。</p>

<h4>
<a name="%E4%B8%8D%E5%AD%98%E5%9C%A8symmetric-nat%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E6%96%B9%E6%98%AFrestrict-nat" class="anchor" href="#%E4%B8%8D%E5%AD%98%E5%9C%A8symmetric-nat%E8%87%B3%E5%B0%91%E6%9C%89%E4%B8%80%E6%96%B9%E6%98%AFrestrict-nat"><span class="octicon octicon-link"></span></a>不存在symmetric NAT，至少有一方是restrict NAT</h4>

<p>这里所指的restrict NAT包含了 RestrictNAT 和 RestrictPortNAT 两种情况。这时，是restrict NAT的那一方需要做一件事，那就是<strong>持续发包！</strong>不妨称这种包为<strong>punching包</strong>，设定为0.5s一次。另一方，不管是不是restrict NAT，接到punching包之后都会自动给出回复。原理上不难理解，因为受限的一方只有持续发包，才能让NAT设备知道对方是“已知”的，而一旦接收到回复，持续发包停止，可以开始聊天。</p>

<h4>
<a name="%E5%8F%8C%E6%96%B9%E9%83%BD%E6%98%AFfull-cone" class="anchor" href="#%E5%8F%8C%E6%96%B9%E9%83%BD%E6%98%AFfull-cone"><span class="octicon octicon-link"></span></a>双方都是Full Cone</h4>

<p>这种情况简直是天堂，直接向对方发送就行了，so easy.<br>
实际上，大部分情况都是这种。看来生活还是有希望的╮(╯▽╰)╭</p>

<p>大概就是这样了。<del>再次声明，代码并未在真实情况下测试过，所以未必一定能正常工作。可以保证的是原理正确，以及在模拟状况下测试正常。</del>目前已经测试过了，各种状况下都能正常工作，除非路由器或者防火墙被设定为阻挡来自某些IP的UDP报文，那确实无能为力了。另外，我不知道ICE是具体是怎么工作的，到处都说是对STUN+TURN的封装，难不成就和这个差不多？</p>