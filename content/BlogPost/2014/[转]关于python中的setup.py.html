<p>转载自孔令贤的博客：<a href="http://lingxiankong.github.io/">http://lingxiankong.github.io/</a>  </p>

<h2>
<a name="user-content-%E5%89%8D%E8%A8%80" class="anchor" href="#%E5%89%8D%E8%A8%80"><span class="octicon octicon-link"></span></a>前言</h2>

<p>其实对于setup.py和setup.cfg的关注是从OpenStack的源码包中开始的，OpenStack每个组件的发布时都是一个tar.gz包，同样，我们直接从github上clone代码后也会发现两个文件的存在。当阅读Nova或Ceilometer（其他组件可能也会涉及）的代码时，发现setup.cfg中内容对于代码的理解有很大的影响。那么，到底setup.py和setup.cfg是干什么的？</p>

<h2>
<a name="user-content-setuppy" class="anchor" href="#setuppy"><span class="octicon octicon-link"></span></a>setup.py</h2>

<p>我们从例子开始。假设你要分发一个叫foo的模块，文件名foo.py，那么setup.py内容如下：</p>

<div class="highlight highlight-python"><pre><span class="kn">from</span> <span class="nn">distutils.core</span> <span class="kn">import</span> <span class="n">setup</span>
<span class="n">setup</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'foo'</span><span class="p">,</span>
      <span class="n">version</span><span class="o">=</span><span class="s">'1.0'</span><span class="p">,</span>
      <span class="n">py_modules</span><span class="o">=</span><span class="p">[</span><span class="s">'foo'</span><span class="p">],</span>
      <span class="p">)</span>   
</pre></div>

<p>然后，运行<code>python setup.py sdist</code>为模块创建一个源码包</p>

<div class="highlight highlight-bash"><pre>root@network:/kong/setup# python setup.py sdist
running sdist
running check
warning: check: missing required meta-data: url 
warning: check: missing meta-data: either <span class="o">(</span>author and author_email<span class="o">)</span> or <span class="o">(</span>maintainer and maintainer_email<span class="o">)</span> must be supplied
warning: sdist: manifest template <span class="s1">'MANIFEST.in'</span> does not exist <span class="o">(</span>using default file list<span class="o">)</span>
warning: sdist: standard file not found: should have one of README, README.txt
writing manifest file <span class="s1">'MANIFEST'</span>
creating foo-1.0
making hard links in foo-1.0...
hard linking foo.py -&gt; foo-1.0
hard linking setup.py -&gt; foo-1.0
creating dist
Creating tar archive
removing <span class="s1">'foo-1.0'</span> <span class="o">(</span>and everything under it<span class="o">)</span>
</pre></div>

<p>在当前目录下，会创建<code>dist</code>目录，里面有个文件名为<code>foo-1.0.tar.gz</code>，这个就是可以分发的包。使用者拿到这个包后，解压，到foo-1.0目录下执行：<code>python setup.py install</code>，那么，foo.py就会被拷贝到python类路径下，可以被导入使用。</p>

<div class="highlight highlight-bash"><pre>root@network:/kong/setup/dist/foo-1.0# python setup.py install
running install
running build
running build_py
creating build
creating build/lib.linux-x86_64-2.7
copying foo.py -&gt; build/lib.linux-x86_64-2.7
running install_lib
copying build/lib.linux-x86_64-2.7/foo.py -&gt; /usr/local/lib/python2.7/dist-packages
byte-compiling /usr/local/lib/python2.7/dist-packages/foo.py to foo.pyc
running install_egg_info
Removing /usr/local/lib/python2.7/dist-packages/foo-1.0.egg-info
Writing /usr/local/lib/python2.7/dist-packages/foo-1.0.egg-info
root@network:/kong/setup/dist/foo-1.0# ll /usr/local/lib/python2.7/dist-packages/foo
foo-1.0.egg-info  foo.py            foo.pyc   
</pre></div>

<p>对于Windows，可以执行<code>python setup.py bdist_wininst</code>生成一个exe文件；若要生成RPM包，执行<code>python setup.py bdist_rpm</code>，但系统必须有rpm命令的支持。可以运行下面的命令查看所有格式的支持：</p>

<div class="highlight highlight-bash"><pre>root@network:/kong/setup# python setup.py bdist --help-formats
List of available distribution formats:
  --formats<span class="o">=</span>rpm      RPM distribution
  --formats<span class="o">=</span>gztar    gzip<span class="s1">'ed tar file</span>
<span class="s1">  --formats=bztar    bzip2'</span>ed tar file
  --formats<span class="o">=</span>ztar     compressed tar file
  --formats<span class="o">=</span>tar      tar file
  --formats<span class="o">=</span>wininst  Windows executable installer
  --formats<span class="o">=</span>zip      ZIP file
  --formats<span class="o">=</span>msi      Microsoft Installer
</pre></div>

<p>setup函数还有一些参数：  </p>

<p>1、<code>packages</code><br>
告诉Distutils需要处理那些包（包含<code>__init__.py</code>的文件夹）<br>
2、<code>package_dir</code><br>
告诉Distutils哪些目录下的文件被映射到哪个源码包。一个例子：<code>package_dir = {'': 'lib'}</code>，表示“root package”中的模块都在lib目录中。<br>
3、<code>ext_modules</code><br>
是一个包含Extension实例的列表，Extension的定义也有一些参数。<br>
4、<code>ext_package</code><br>
定义extension的相对路径<br>
5、<code>requires</code><br>
定义依赖哪些模块<br>
6、<code>provides</code><br>
定义可以为哪些模块提供依赖<br>
7、<code>scripts</code><br>
指定python源码文件，可以从命令行执行。在安装时指定<code>--install-script</code><br>
8、<code>package_data</code><br>
通常包含与包实现相关的一些数据文件或类似于readme的文件。如果没有提供模板，会被添加到MANIFEST文件中。<br>
9、<code>data_files</code><br>
指定其他的一些文件（如配置文件）  </p>

<div class="highlight highlight-python"><pre><span class="n">setup</span><span class="p">(</span><span class="o">...</span><span class="p">,</span>
      <span class="n">data_files</span><span class="o">=</span><span class="p">[(</span><span class="s">'bitmaps'</span><span class="p">,</span> <span class="p">[</span><span class="s">'bm/b1.gif'</span><span class="p">,</span> <span class="s">'bm/b2.gif'</span><span class="p">]),</span>
                  <span class="p">(</span><span class="s">'config'</span><span class="p">,</span> <span class="p">[</span><span class="s">'cfg/data.cfg'</span><span class="p">]),</span>
                  <span class="p">(</span><span class="s">'/etc/init.d'</span><span class="p">,</span> <span class="p">[</span><span class="s">'init-script'</span><span class="p">])]</span>
     <span class="p">)</span>
</pre></div>

<p>规定了哪些文件被安装到哪些目录中。如果目录名是相对路径，则是相对于<code>sys.prefix</code>或<code>sys.exec_prefix</code>的路径。如果没有提供模板，会被添加到MANIFEST文件中。</p>

<p>执行sdist命令时，默认会打包哪些东西呢？  </p>

<ul>
<li>所有由<code>py_modules</code>或<code>packages</code>指定的源码文件<br>
</li>
<li>所有由<code>ext_modules</code>或<code>libraries</code>指定的C源码文件<br>
</li>
<li>由<code>scripts</code>指定的脚本文件<br>
</li>
<li>类似于test/test*.py的文件<br>
</li>
<li>README.txt或README，setup.py，setup.cfg<br>
</li>
<li>所有<code>package_data</code>或<code>data_files</code>指定的文件<br>
</li>
</ul><p>还有一种方式是写一个manifest template，名为<code>MANIFEST.in</code>，定义如何生成MANIFEST文件，内容就是需要包含在分发包中的文件。一个MANIFEST.in文件如下：</p>

<pre><code>include *.txt
recursive-include examples *.txt *.py
prune examples/sample?/build
</code></pre>

<h2>
<a name="user-content-setupcfg" class="anchor" href="#setupcfg"><span class="octicon octicon-link"></span></a>setup.cfg</h2>

<p>setup.cfg提供一种方式，可以让包的开发者提供命令的默认选项，同时为用户提供修改的机会。对setup.cfg的解析，是在setup.py之后，在命令行执行前。</p>

<p>setup.cfg文件的形式类似于  </p>

<pre><code>[command]
option=value
...
</code></pre>

<p>其中，<code>command</code>是Distutils的命令参数，<code>option</code>是参数选项，可以通过<code>python setup.py --help build_ext</code>方式获取。  </p>

<blockquote>
<p>需要注意的是，比如一个选项是--foo-bar，在setup.cfg中必须改成foo_bar的格式</p>
</blockquote>

<p>符合Distutils2的setup.cfg有些不同。包含一些sections：<br>
1、<code>global</code><br>
定义Distutils2的全局选项，可能包含commands，compilers，setup_hook（定义脚本，在setup.cfg被读取后执行，可以修改setup.cfg的配置）<br>
2、<code>metadata</code><br>
3、<code>files</code>  </p>

<ul>
<li>packages_root：根目录</li>
<li>packages</li>
<li>modules</li>
<li>scripts</li>
<li>extra_files</li>
</ul><p>4、<em>command</em> sections</p>

<h2>
<a name="user-content-setuptools" class="anchor" href="#setuptools"><span class="octicon octicon-link"></span></a>Setuptools</h2>

<p>上面的setup.py和setup.cfg都是遵循python标准库中的Distutils，而setuptools工具针对Python官方的distutils做了很多针对性的功能增强，比如依赖检查，动态扩展等。很多高级功能我就不详述了，自己也没有用过，等用的时候再作补充。</p>

<p>一个典型的遵循setuptools的脚本：</p>

<div class="highlight highlight-python"><pre><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">find_packages</span>
<span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"HelloWorld"</span><span class="p">,</span>
    <span class="n">version</span> <span class="o">=</span> <span class="s">"0.1"</span><span class="p">,</span>
    <span class="n">packages</span> <span class="o">=</span> <span class="n">find_packages</span><span class="p">(),</span>
    <span class="n">scripts</span> <span class="o">=</span> <span class="p">[</span><span class="s">'say_hello.py'</span><span class="p">],</span>

    <span class="c"># Project uses reStructuredText, so ensure that the docutils get</span>
    <span class="c"># installed or upgraded on the target machine</span>
    <span class="n">install_requires</span> <span class="o">=</span> <span class="p">[</span><span class="s">'docutils&gt;=0.3'</span><span class="p">],</span>

    <span class="n">package_data</span> <span class="o">=</span> <span class="p">{</span>
        <span class="c"># If any package contains *.txt or *.rst files, include them:</span>
        <span class="s">''</span><span class="p">:</span> <span class="p">[</span><span class="s">'*.txt'</span><span class="p">,</span> <span class="s">'*.rst'</span><span class="p">],</span>
        <span class="c"># And include any *.msg files found in the 'hello' package, too:</span>
        <span class="s">'hello'</span><span class="p">:</span> <span class="p">[</span><span class="s">'*.msg'</span><span class="p">],</span>
    <span class="p">},</span>

    <span class="c"># metadata for upload to PyPI</span>
    <span class="n">author</span> <span class="o">=</span> <span class="s">"Me"</span><span class="p">,</span>
    <span class="n">author_email</span> <span class="o">=</span> <span class="s">"me@example.com"</span><span class="p">,</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s">"This is an Example Package"</span><span class="p">,</span>
    <span class="n">license</span> <span class="o">=</span> <span class="s">"PSF"</span><span class="p">,</span>
    <span class="n">keywords</span> <span class="o">=</span> <span class="s">"hello world example examples"</span><span class="p">,</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s">"http://example.com/HelloWorld/"</span><span class="p">,</span>   <span class="c"># project home page, if any</span>

    <span class="c"># could also include long_description, download_url, classifiers, etc.</span>
<span class="p">)</span>
</pre></div>

<h3>
<a name="user-content-%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AAegg%E5%8F%AF%E8%A2%AB%E6%89%A7%E8%A1%8C" class="anchor" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E4%B8%80%E4%B8%AAegg%E5%8F%AF%E8%A2%AB%E6%89%A7%E8%A1%8C"><span class="octicon octicon-link"></span></a>如何让一个egg可被执行？</h3>

<div class="highlight highlight-python"><pre><span class="n">setup</span><span class="p">(</span>
    <span class="c"># other arguments here...</span>
    <span class="n">entry_points</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'setuptools.installation'</span><span class="p">:</span> <span class="p">[</span>
            <span class="s">'eggsecutable = my_package.some_module:main_func'</span><span class="p">,</span>
        <span class="p">]</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>

<h3>
<a name="user-content-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%80%89%E7%89%B9%E6%80%A7" class="anchor" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%8F%AF%E9%80%89%E7%89%B9%E6%80%A7"><span class="octicon octicon-link"></span></a>如何定义一个可选特性？</h3>

<div class="highlight highlight-python"><pre><span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">"Project-A"</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="n">extras_require</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'PDF'</span><span class="p">:</span>  <span class="p">[</span><span class="s">"ReportLab&gt;=1.2"</span><span class="p">,</span> <span class="s">"RXP"</span><span class="p">],</span>
        <span class="s">'reST'</span><span class="p">:</span> <span class="p">[</span><span class="s">"docutils&gt;=0.3"</span><span class="p">],</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>

<p>特性如何使用呢？需要与entry points结合使用：</p>

<div class="highlight highlight-python"><pre><span class="n">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">"Project-A"</span><span class="p">,</span>
    <span class="o">...</span>
    <span class="n">entry_points</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'console_scripts'</span><span class="p">:</span> <span class="p">[</span>
            <span class="s">'rst2pdf = project_a.tools.pdfgen [PDF]'</span><span class="p">,</span>
            <span class="s">'rst2html = project_a.tools.htmlgen'</span><span class="p">,</span>
            <span class="c"># more script entry points ...</span>
        <span class="p">],</span>
    <span class="p">}</span>
<span class="p">)</span>
</pre></div>

<p>或者被其他project依赖：install_requires = ["Project-A[PDF]"]</p>

<h3>
<a name="user-content-%E6%8F%92%E4%BB%B6%E5%BC%8F%E5%BC%80%E5%8F%91" class="anchor" href="#%E6%8F%92%E4%BB%B6%E5%BC%8F%E5%BC%80%E5%8F%91"><span class="octicon octicon-link"></span></a>插件式开发</h3>

<p>我想大家最熟悉的就是这个特性了吧。比如一个博客系统想用不同的插件支持不同的语言输出格式，那么就可以定义一个“entry point group”，不同的插件就可以注册“entry point”，插件注册的示例：</p>

<div class="highlight highlight-python"><pre><span class="n">setup</span><span class="p">(</span>
    <span class="c"># ...</span>
    <span class="n">entry_points</span> <span class="o">=</span> <span class="p">{</span><span class="s">'blogtool.parsers'</span><span class="p">:</span> <span class="p">[</span><span class="s">'.rst = some_module:a_func'</span><span class="p">]}</span>
<span class="p">)</span>

<span class="c"># 或者</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="c"># ...</span>
    <span class="n">entry_points</span> <span class="o">=</span> <span class="s">"""</span>
<span class="s">        [blogtool.parsers]</span>
<span class="s">        .rst = some.nested.module:SomeClass.some_classmethod [reST]</span>
<span class="s">    """</span><span class="p">,</span>
    <span class="n">extras_require</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">reST</span> <span class="o">=</span> <span class="s">"Docutils&gt;=0.3.5"</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>

<h3>
<a name="user-content-setuptools%E4%B8%AD%E7%9A%84dependency_links" class="anchor" href="#setuptools%E4%B8%AD%E7%9A%84dependency_links"><span class="octicon octicon-link"></span></a>Setuptools中的dependency_links</h3>

<p>Setuptools有一个功能叫做 dependency_links</p>

<div class="highlight highlight-python"><pre><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="c"># ...</span>
    <span class="n">dependency_links</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s">"http://packages.example.com/snapshots/"</span><span class="p">,</span>
        <span class="s">"http://example2.com/p/bar-1.0.tar.gz"</span><span class="p">,</span>
    <span class="p">],</span>
<span class="p">)</span>
</pre></div>

<p>这一功能除去了依赖的抽象特性，直接把依赖的获取url标在了setup.py里。就像在Go语言中修改依赖包一样，我们只需要修改依赖链中每个包的 dependency_links 。</p>

<h3>
<a name="user-content-%E7%AE%A1%E7%90%86%E4%BE%9D%E8%B5%96" class="anchor" href="#%E7%AE%A1%E7%90%86%E4%BE%9D%E8%B5%96"><span class="octicon octicon-link"></span></a>管理依赖</h3>

<p>我们写依赖声明的时候需要在 setup.py 中写好抽象依赖（install_requires），在 requirements.txt 中写好具体的依赖，但是我们并不想维护两份依赖文件，这样会让我们很难做好同步。 requirements.txt 可以更好地处理这种情况，我们可以在有 setup.py 的目录里写下一个这样的 requirements.txt</p>

<pre><code>--index https://pypi.python.org/simple/

-e .
</code></pre>

<p>这样 pip install -r requirements.txt 可以照常工作，它会先安装该文件路径下的包，然后继续开始解析抽象依赖，结合 --index 选项后转换为具体依赖然后再安装他们。</p>

<p>这个办法可以让我们解决一种类似这样的情形：比如你有两个或两个以上的包在一起开发但是是分开发行的，或者说你有一个尚未发布的包并把它分成了几个部分。如果你的顶层的包 依然仅仅按照“名字”来依赖的话，我们依然可以使用 requirements.txt 来安装开发版本的依赖包:</p>

<pre><code>--index https://pypi.python.org/simple/

-e https://github.com/foo/bar.git#egg=bar
-e .
</code></pre>

<p>这会首先从 <a href="https://github.com/foo/bar.git">https://github.com/foo/bar.git</a> 来安装包 bar ， 然后进行到第二行 -e . ，开始安装 setup 中的抽象依赖，但是包 bar 已经安装过了， 所以 pip 会跳过安装。</p>

<h2>
<a name="user-content-differences-between-distribute-distutils-setuptools-and-distutils2" class="anchor" href="#differences-between-distribute-distutils-setuptools-and-distutils2"><span class="octicon octicon-link"></span></a>Differences between distribute, distutils, setuptools and distutils2</h2>

<p><strong>Distutils</strong> is the standard tool used for packaging. It works rather well for simple needs, but is limited and not trivial to extend.</p>

<p><strong>Setuptools</strong> is a project born from the desire to fill missing distutils functionality and explore new directions. In some subcommunities, it’s a de facto standard. It uses monkey-patching and magic that is frowned upon by Python core developers.</p>

<p><strong>Distribute</strong> is a fork of Setuptools that was started by developers feeling that its development pace was too slow and that it was not possible to evolve it. Its development was considerably slowed when distutils2 was started by the same group. 2013-August update: distribute is merged back into setuptools and discontinued.</p>

<p><strong>Distutils2</strong> is a new distutils library, started as a fork of the distutils codebase, with good ideas taken from setup tools (of which some were thoroughly discussed in PEPs), and a basic installer inspired by pip. The actual name you use to import Distutils2 is packaging in the Python 3.3+ standard library, or distutils2 in 2.4+ and 3.1–3.2. (A backport will be available soon.) Distutils2 did not make the Python 3.3 release, and it was put on hold.</p>

<h2>
<a name="user-content-pbr" class="anchor" href="#pbr"><span class="octicon octicon-link"></span></a>PBR</h2>

<p><a href="https://pypi.python.org/pypi/pbr">pbr</a>是setuptools的辅助工具，最初是为OpenStack开发(<a href="https://launchpad.net/pbr)%EF%BC%8C%E5%9F%BA%E4%BA%8E%5Bd2to1%5D(https://pypi.python.org/pypi/d2to1)%E3%80%82">https://launchpad.net/pbr)，基于[d2to1](https://pypi.python.org/pypi/d2to1)。</a>  </p>

<blockquote>
<p>A library for managing setuptools packaging needs in a consistent manner.</p>
</blockquote>

<p>pbr会读取和过滤setup.cfg中的数据，然后将解析后的数据提供给setup.py作为参数。包含如下功能：<br>
1、从git中获取Version、AUTHORS and ChangeLog信息<br>
2、Sphinx Autodoc。pbr会扫描project，找到所有模块，生成stub files<br>
3、Requirements。pbr会读取requirements.txt，生成setup函数需要的<code>install_requires/tests_require/dependency_links</code>  </p>

<blockquote>
<p>这里需要注意，在requirements.txt文件的头部可以使用：<code>--index https://pypi.python.org/simple/</code>，这一行把一个抽象的依赖声明如 requests==1.2.0 转变为一个具体的依赖声明 requests 1.2.0 from pypi.python.org/simple/   </p>
</blockquote>

<p>4、long_description。从README.rst, README.txt or README file中生成<code>long_description</code>参数</p>

<p>使用pbr很简单：</p>

<div class="highlight highlight-python"><pre><span class="kn">from</span> <span class="nn">setuptools</span> <span class="kn">import</span> <span class="n">setup</span>

<span class="n">setup</span><span class="p">(</span>
    <span class="n">setup_requires</span><span class="o">=</span><span class="p">[</span><span class="s">'pbr'</span><span class="p">],</span>
    <span class="n">pbr</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
<span class="p">)</span>
</pre></div>

<p>使用pbr时，setup.cfg中有一些配置。在[files]中，有三个key：<br><code>packages</code>:指定需要包含的包，行为类似于setuptools.find_packages<br><code>namespace_packages</code>:指定namespace packages<br><code>data_files</code>: 指定目的目录和源文件路径，一个示例：</p>

<pre><code>[files]
data_files =
    etc/pbr = etc/pbr/*
    etc/neutron =
        etc/api-paste.ini
        etc/dhcp-agent.ini
    etc/init.d = neutron.init
</code></pre>

<p>[entry_points]段跟setuptools的方式相同。</p>

<h2>
<a name="user-content-babel" class="anchor" href="#babel"><span class="octicon octicon-link"></span></a>Babel</h2>

<blockquote>
<p>A collection of tools for internationalizing Python applications</p>
</blockquote>

<p><a href="http://babel.edgewall.org/">Babel</a>是 Python 的一个国际化工具包，提供了对distutils或setuptools的支持，包含一些命令。</p>

<p>1、compile_catalog<br>
类似于msgfmt工具，takes a message catalog from a PO file and compiles it to a binary MO file.  </p>

<div class="highlight highlight-bash"><pre><span class="nv">$ </span>./setup.py compile_catalog --directory foobar/locale --locale pt_BR
running compile_catalog
compiling catalog to foobar/locale/pt_BR/LC_MESSAGES/messages.mo
</pre></div>

<p>2、extract_messages<br>
类似于xgettext，it can extract localizable messages from a variety of difference source files, and generate a PO (portable object) template file from the collected messages.</p>

<div class="highlight highlight-bash"><pre><span class="nv">$ </span>./setup.py extract_messages --output-file foobar/locale/messages.pot
running extract_messages
extracting messages from foobar/__init__.py
extracting messages from foobar/core.py
...
writing PO template file to foobar/locale/messages.pot
</pre></div>

<p>3、update_catalog<br>
类似于msgmerge，it updates an existing translations catalog based on a PO template file (POT).</p>

<h2>
<a name="user-content-setuppy%E5%92%8Cpip" class="anchor" href="#setuppy%E5%92%8Cpip"><span class="octicon octicon-link"></span></a>setup.py和pip</h2>

<p>表面上，<code>python setup.py install</code>和<code>pip install</code>都是用来安装python包的，实际上，<code>pip</code>提供了更多的特性，更易于使用。体现在以下几个方面：</p>

<ul>
<li>pip会自动下载依赖，而如果使用setup.py，则需要手动搜索和下载；</li>
<li>pip会自动管理包的信息，使卸载/更新更加方便和容易，使用<code>pip uninstall</code>即可。而使用setup.py，必须手动删除，有时容易出错。</li>
<li>pip提供了对<code>virtualenv</code>更好的整合。</li>
</ul><h2>
<a name="user-content-%E7%BB%93%E8%AF%AD" class="anchor" href="#%E7%BB%93%E8%AF%AD"><span class="octicon octicon-link"></span></a>结语</h2>

<p>OK，讲了这么多琐碎的东西，现在去看看Nova或Ceilometer的setup脚本，是不是一下清晰了很多？！但说实话，setup.py的使用，我还不能讲的特别清楚，需要在后续的实战中学习。</p>

<hr><p>参考文档：<br><a href="http://docs.python.org/2/distutils/introduction.html">http://docs.python.org/2/distutils/introduction.html</a><br><a href="http://pythonhosted.org/setuptools/">http://pythonhosted.org/setuptools/</a></p>