<p>本文是对<a href="http://stackoverflow.com/questions/14132789/python-relative-imports-for-the-billionth-time#answer-14132912">http://stackoverflow.com/questions/14132789/python-relative-imports-for-the-billionth-time#answer-14132912</a>这个SO答案的翻译。本人的翻译一向只追求含义准确而不追求字字对应，有些不好翻的术语或者固定说法就直接保留。</p>

<p>这个答案能解释大多关于relative import，即相对导入的疑惑，讲解十分详尽清晰，算是SO上被低估的一个答案。</p>

<p>问题不翻译了，直接摘录下来：<br>
The forever-recurring question is this: With Windows 7, 32-bit Python 2.7.3, how do I solve this "Attempted relative import in non-package" message? I built an exact replica of the package on pep-0328:</p>

<pre><code>package/

    __init__.py

    subpackage1/

        __init__.py

        moduleX.py

        moduleY.py

    subpackage2/

        __init__.py

        moduleZ.py

    moduleA.py
</code></pre>

<p>I did make functions named spam and eggs in their appropriate modules. Naturally, it didn't work. The answer is apparently in the 4th URL I listed, but it's all alumni to me. There was this response on one of the URLs I visited:</p>

<p>Relative imports use a module's name attribute to determine that module's position in the package hierarchy. If the module's name does not contain any package information (e.g. it is set to 'main') then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.</p>

<p>The above response looks promising, but it's all hieroglyphs to me. So my question, how do I make Python not return to me "Attempted relative import in non-package"? has an answer that involves -m, supposedly.</p>

<p>Can somebody please tell me why Python gives that error message, what it Means by non-package!, why and how do you define a 'package', and <strong>the precise answer put in terms easy enough for a kindergartener to understand.</strong> Thanks in advance!</p>

<p>Edit: The imports were done from the console.</p>

<hr>

<h3>
<a id="user-content-brenbarn的精彩答案这个哥们可以算是import专家了答了好多这方面的题" class="anchor" href="#brenbarn%E7%9A%84%E7%B2%BE%E5%BD%A9%E7%AD%94%E6%A1%88%E8%BF%99%E4%B8%AA%E5%93%A5%E4%BB%AC%E5%8F%AF%E4%BB%A5%E7%AE%97%E6%98%AFimport%E4%B8%93%E5%AE%B6%E4%BA%86%E7%AD%94%E4%BA%86%E5%A5%BD%E5%A4%9A%E8%BF%99%E6%96%B9%E9%9D%A2%E7%9A%84%E9%A2%98" aria-hidden="true"><span class="octicon octicon-link"></span></a>
<a href="http://stackoverflow.com/users/1427416/brenbarn">BrenBarn</a>的精彩答案（这个哥们可以算是import专家了，答了好多这方面的题）</h3>

<p>简单地说，直接运行.Py文件和import这个文件有很大区别。Python解释器判断一个py文件属于哪个package时并不完全由该文件所在的文件夹决定。它还取决于这个文件是如何load进来的（直接运行or import）。</p>

<p>有两种方式加载一个py文件：作为top-level脚本或者作为module。前者指的是直接运行脚本，比如<code>python myfile.py</code>。如果执行<code>python -m myfile</code>，或者在其它py文件中用<code>import</code>语句来加载，那么它就会被当作一个module。有且只能有一个top-level脚本，就是最开始执行的那个（比如<code>python myfile.py</code>中的<code>myfile.py</code>，译者注）。</p>

<p>当一个py文件被加载之后，它会被赋予一个名字，保存在<code>__name__</code>属性中。如果是top-level脚本，那么名字就是<code>__main__</code>。如果是作为module，名字就是把它所在的packages/subpackages和文件名用<code>.</code>连接起来。</p>

<p>例如，<code>moduleX</code>被import进来，它的名字就是<code>package.subpackage1.moduleX</code>。如果import了<code>moduleA</code>，它的名字是<code>package.moduleA</code>。如果直接运行<code>moduleX</code>或<code>moduleA</code>，那么名字就都是<code>__main__</code>了。</p>

<p>另一个令人担忧的问题是，一个module的名字取决于它是直接从它所在的文件夹import还是通过某个package import的。不过只有当你在某个路径中运行Python并试图从当前文件夹import一个py文件时，才需要关注它们的不同。例如，在路径<code>pacakge/subpackage1</code>中运行python解释器，然后脚本中有<code>import moduleX</code>这个语句，此时<code>moduleX</code>的名字正是<code>moduleX</code>，而不是<code>package.subpackage1.moduleX</code>。这是因为Python解释器在启动时把当前路径加入了它的搜索路径(search path)；如果发现要import的module就在当前路径，那么Python解释器就不知道当前路径是属于哪个package的，所以pacakge的信息就不会成为module的名字的一部分。</p>

<p>一个特例是直接运行python REPL，这个REPL的session的名字是<code>__main__</code>。</p>

<p>关于你遇到的错误信息，关键点来了：<strong>如果一个module的名字中没有点（即package.subpackage1中的那个点，译者注），那么它就被认为不属于任何一个package</strong>。文件在磁盘上的位置在哪里都不影响，唯一起决定作用的就是<em>module的名字</em>，而这又取决于它是如何被加载的。</p>

<p>先在我们看看你在问题中引用的这段话</p>

<blockquote>
<p>Relative imports use a module's name attribute to determine that module's position in the package hierarchy. If the module's name does not contain any package information (e.g. it is set to 'main') then relative imports are resolved as if the module were a top level module, regardless of where the module is actually located on the file system.  </p>
</blockquote>

<p>relative import使用module的名字来决定它是否属于一个package，属于哪个package。当你使用这种relative import <code>from .. import foo</code>，其中的点的数量代表了package结构中的某个层次。例如，如果当前module的名字是<code>package.subpackage1.moduleX</code>，那么<code>..moduleA</code>代表<code>package.moduleA</code>。为了让形如<code>from .. import</code>的这种导入能够正常工作，module的名字里的点数量应当至少和import语句中一样多。</p>

<p>前面说了，如果module的名字是<code>__main__</code>，那么Python就不认为它属于某个package。<strong>由于名字里不包含点，所以在这个py文件中<code>from .. import</code>语句无法正常工作</strong>。试图执行这条语句就会报"relative-import in non-package"错误。</p>

<p>你犯的错误可能是从命令行运行<code>moduleX</code>或类似的操作。当你执行这个操作，moduleX的名字被设置成<code>__main__</code>，所以relative imports失败了，因为不包含package信息。正如前面说的，如果在同一个路径里import一个文件，这时module的名字就是文件名，不包含package信息，所以相对导入也会失败。</p>

<p>记住，因为REPL session的名字总是<code>__main__</code>，所以试图在REPL里执行relative import是不行的。relative import应当只在module文件中被使用。</p>

<p>（无法相对导入的问题）有两个解决方法。如果你真的想直接运行<code>moduleX</code>，同时又希望它被当作所在package的一部分，可以这么做：<code>python -m package.subpackage.moduleX</code>。<code>-m</code>参数告诉Python解释器，把这个文件当作一个module载入，而不是top-level脚本。</p>

<p>如果你并不想直接运行<code>moduleX</code>，而是想在另一个文件比如<code>myfile.py</code>中使用<code>moduleX</code>中定义的函数，那么解决方法是把<code>myfile.py</code>文件挪到另一个地方，只要不在<code>moduleX</code>所属的package的文件夹里就行。然后在<code>myfile.py</code>中执行<code>from package.moduleA import spam</code>，就能正常工作了。</p>

<p>注意，不论哪种解决方案，都需要package的路径（上文中的<code>package</code>）在python的搜索路径也就是<code>sys.path</code>里。如果不在，那么就无法使用这个package中的任何文件。</p>

<p>（更严谨的说明：从Python2.6开始，在做package-resolution时，module的“名字”并不完全等于<code>__name__</code>属性，还和<code>__package__</code>属性有关。这也是为什么上文中我一直尽量避免用<code>__name__</code>来指代module的名字。从python2.6开始，一个module的“名字”实际上是<code>__package__ + '.' + __name__</code>, 或者直接就是<code>__name__</code>，如果<code>__package__</code>是 <code>None</code>的话）</p>
